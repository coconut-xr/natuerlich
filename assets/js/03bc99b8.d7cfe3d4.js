"use strict";(self.webpackChunknatuerlich_docs=self.webpackChunknatuerlich_docs||[]).push([[905],{3686:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>d});var a=n(7462),i=(n(7294),n(3905));const o={},r="All Hooks Documentation",s={unversionedId:"all-hooks",id:"all-hooks",title:"All Hooks Documentation",description:"useSessionSupported",source:"@site/docs/all-hooks.md",sourceDirName:".",slug:"/all-hooks",permalink:"/natuerlich/all-hooks",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"mainSidebar",previous:{title:"All Components Documentation",permalink:"/natuerlich/all-components"}},l={},d=[{value:"<code>useSessionSupported</code>",id:"usesessionsupported",level:2},{value:"<code>useFocusState</code>",id:"usefocusstate",level:2},{value:"<code>useAnchor</code>",id:"useanchor",level:2},{value:"<code>usePersistedAnchor</code>",id:"usepersistedanchor",level:2},{value:"<code>useSessionChange</code>",id:"usesessionchange",level:2},{value:"<code>useInputSourceChange</code>",id:"useinputsourcechange",level:2},{value:"<code>useInputSourceEvent</code>",id:"useinputsourceevent",level:2},{value:"<code>useInputSources</code>",id:"useinputsources",level:2},{value:"<code>useInputSourceProfile</code>",id:"useinputsourceprofile",level:2},{value:"<code>useInitRoomCapture</code>",id:"useinitroomcapture",level:2},{value:"<code>useTrackedPlanes</code>",id:"usetrackedplanes",level:2},{value:"<code>useTrackedPlaneObjects</code>",id:"usetrackedplaneobjects",level:2},{value:"<code>useTrackedPlaneGeometry</code>",id:"usetrackedplanegeometry",level:2},{value:"<code>useTrackedMeshes</code>",id:"usetrackedmeshes",level:2},{value:"<code>useTrackedMeshObjects</code>",id:"usetrackedmeshobjects",level:2},{value:"<code>useTrackedMeshGeometry</code>",id:"usetrackedmeshgeometry",level:2},{value:"<code>useHandPoses</code>",id:"usehandposes",level:2},{value:"<code>useApplySpace</code>",id:"useapplyspace",level:2},{value:"<code>useXR</code>",id:"usexr",level:2},{value:"<code>useEnterXR</code>",id:"useenterxr",level:2},{value:"<code>useSessionGrant</code>",id:"usesessiongrant",level:2},{value:"<code>useLayer</code>",id:"uselayer",level:2},{value:"<code>useLayerUpdate</code>",id:"uselayerupdate",level:2},{value:"<code>useNativeFramebufferScaling</code>",id:"usenativeframebufferscaling",level:2},{value:"<code>useAvailableFrameRates</code>",id:"useavailableframerates",level:2},{value:"<code>useHeighestAvailableFrameRate</code>",id:"useheighestavailableframerate",level:2},{value:"<code>useXRGamepadReader</code>",id:"usexrgamepadreader",level:2},{value:"<code>useXRGamepadButton</code>",id:"usexrgamepadbutton",level:2}],u={toc:d},p="wrapper";function h(e){let{components:t,...n}=e;return(0,i.kt)(p,(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"all-hooks-documentation"},"All Hooks Documentation"),(0,i.kt)("h2",{id:"usesessionsupported"},(0,i.kt)("inlineCode",{parentName:"h2"},"useSessionSupported")),(0,i.kt)("p",null,"This hook is used to determine if a xr mode is supported. The hook takes the xr mode (e.g. ",(0,i.kt)("inlineCode",{parentName:"p"},"immersive-ar"),") to request support for as its only parameter and whether the passed xr mode is supported.\nThe hook returns undefined while the request for the mode is not yet resolved."),(0,i.kt)("h2",{id:"usefocusstate"},(0,i.kt)("inlineCode",{parentName:"h2"},"useFocusState")),(0,i.kt)("p",null,"This hook is used to retrieve the current focus state. The hook returns the focus state if the user is currently in an xr session and ",(0,i.kt)("inlineCode",{parentName:"p"},"undefined")," if no session is present. The focus state can be ",(0,i.kt)("inlineCode",{parentName:"p"},"visible"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"visible-blurred"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"hidden"),". For example, in the meta quest operating system, the focus state is ",(0,i.kt)("inlineCode",{parentName:"p"},"visible-blurred")," when the user interacts with the operating system while the session is still in the background."),(0,i.kt)("h2",{id:"useanchor"},(0,i.kt)("inlineCode",{parentName:"h2"},"useAnchor")),(0,i.kt)("p",null,"This hook is used to create and store anchors. It operates similar to the ",(0,i.kt)("inlineCode",{parentName:"p"},"useState")," React hook. The hook returns a tuple where the first item is the anchor (of type ",(0,i.kt)("inlineCode",{parentName:"p"},"XRAnchor"),") and the second item is a function that can be used to create a new anchor. The function to create a new anchor takes in two arguments: ",(0,i.kt)("inlineCode",{parentName:"p"},"worldPosition")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"worldRotation"),", which are of the ",(0,i.kt)("inlineCode",{parentName:"p"},"Vector3")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Quaternion")," types respectively. "),(0,i.kt)("h2",{id:"usepersistedanchor"},(0,i.kt)("inlineCode",{parentName:"h2"},"usePersistedAnchor")),(0,i.kt)("p",null,"This hook is used to create and store anchors that are also persisted in local storage. The hook requires a ",(0,i.kt)("inlineCode",{parentName:"p"},"key")," of type ",(0,i.kt)("inlineCode",{parentName:"p"},"string")," which is used to store and load the anchor ID. Similar to the ",(0,i.kt)("inlineCode",{parentName:"p"},"useAnchor")," hook, it also returns a tuple with the first item being the anchor and the second item being a function that can be used to create a new anchor."),(0,i.kt)("h2",{id:"usesessionchange"},(0,i.kt)("inlineCode",{parentName:"h2"},"useSessionChange")),(0,i.kt)("p",null,"This hook is used to handle session changes. It requires a callback function ",(0,i.kt)("inlineCode",{parentName:"p"},"onSessionChange")," that gets executed when the session changes. This function should have two parameters, the current session and the previous session, both of type ",(0,i.kt)("inlineCode",{parentName:"p"},"XRSession"),". Additionally, you need to provide a list of dependencies (",(0,i.kt)("inlineCode",{parentName:"p"},"deps"),"), which if changed, trigger the ",(0,i.kt)("inlineCode",{parentName:"p"},"onSessionChange")," callback."),(0,i.kt)("h2",{id:"useinputsourcechange"},(0,i.kt)("inlineCode",{parentName:"h2"},"useInputSourceChange")),(0,i.kt)("p",null,"This hook gets triggered when the input sources change. It takes a callback function ",(0,i.kt)("inlineCode",{parentName:"p"},"onXRInputSourcesChange")," that gets executed when the change happens. The function has a parameter ",(0,i.kt)("inlineCode",{parentName:"p"},"e")," of type ",(0,i.kt)("inlineCode",{parentName:"p"},"XRInputSourceChangeEvent"),". Similar to ",(0,i.kt)("inlineCode",{parentName:"p"},"useSessionChange"),", you also need to provide a list of dependencies (",(0,i.kt)("inlineCode",{parentName:"p"},"deps"),"), which if changed, trigger the ",(0,i.kt)("inlineCode",{parentName:"p"},"onXRInputSourcesChange")," callback."),(0,i.kt)("h2",{id:"useinputsourceevent"},(0,i.kt)("inlineCode",{parentName:"h2"},"useInputSourceEvent")),(0,i.kt)("p",null,'This hook can be used to attach event listeners to input sources. It accepts the name of the event (either "select", "selectstart", "selectend", "squeeze", "squeezestart", or "squeezeend"), the input source (',(0,i.kt)("inlineCode",{parentName:"p"},"inputSource")," of type ",(0,i.kt)("inlineCode",{parentName:"p"},"XRInputSource"),"), a callback function ",(0,i.kt)("inlineCode",{parentName:"p"},"callback")," that gets called when the event is triggered, and a list of dependencies (",(0,i.kt)("inlineCode",{parentName:"p"},"deps"),") that cause the callback to change."),(0,i.kt)("h2",{id:"useinputsources"},(0,i.kt)("inlineCode",{parentName:"h2"},"useInputSources")),(0,i.kt)("p",null,"This hook returns an array of currently active input sources of type ",(0,i.kt)("inlineCode",{parentName:"p"},"XRInputSource"),"."),(0,i.kt)("h2",{id:"useinputsourceprofile"},(0,i.kt)("inlineCode",{parentName:"h2"},"useInputSourceProfile")),(0,i.kt)("p",null,"This hook returns the controller profile information based on the available input source profiles (use ",(0,i.kt)("inlineCode",{parentName:"p"},"useInputSourceProfile(inputSource.profiles)"),")."),(0,i.kt)("h2",{id:"useinitroomcapture"},(0,i.kt)("inlineCode",{parentName:"h2"},"useInitRoomCapture")),(0,i.kt)("p",null,"This hook returns a function that triggers room setup for WebXR tracked planes."),(0,i.kt)("h2",{id:"usetrackedplanes"},(0,i.kt)("inlineCode",{parentName:"h2"},"useTrackedPlanes")),(0,i.kt)("p",null,"This hook returns a readonly array of currently tracked planes (",(0,i.kt)("inlineCode",{parentName:"p"},"XRPlane"),")."),(0,i.kt)("h2",{id:"usetrackedplaneobjects"},(0,i.kt)("inlineCode",{parentName:"h2"},"useTrackedPlaneObjects")),(0,i.kt)("p",null,"This hook returns a readonly array of currently tracked planes (",(0,i.kt)("inlineCode",{parentName:"p"},"XRPlane"),") with a specific semantic label."),(0,i.kt)("h2",{id:"usetrackedplanegeometry"},(0,i.kt)("inlineCode",{parentName:"h2"},"useTrackedPlaneGeometry")),(0,i.kt)("p",null,"This hook returns the geometry for a ",(0,i.kt)("inlineCode",{parentName:"p"},"XRPlane"),". The parameter ",(0,i.kt)("inlineCode",{parentName:"p"},"disposeBuffer")," specifies whether the buffers should be automatically cleaned up (default: true)."),(0,i.kt)("h2",{id:"usetrackedmeshes"},(0,i.kt)("inlineCode",{parentName:"h2"},"useTrackedMeshes")),(0,i.kt)("p",null,"This hook returns a readonly array of currently tracked meshes (",(0,i.kt)("inlineCode",{parentName:"p"},"XRMesh"),")."),(0,i.kt)("h2",{id:"usetrackedmeshobjects"},(0,i.kt)("inlineCode",{parentName:"h2"},"useTrackedMeshObjects")),(0,i.kt)("p",null,"This hook returns a readonly array of currently tracked mesh (",(0,i.kt)("inlineCode",{parentName:"p"},"XRMesh"),") with a specific semantic label."),(0,i.kt)("h2",{id:"usetrackedmeshgeometry"},(0,i.kt)("inlineCode",{parentName:"h2"},"useTrackedMeshGeometry")),(0,i.kt)("p",null,"This hook returns the geometry for a ",(0,i.kt)("inlineCode",{parentName:"p"},"XRMesh"),". The parameter ",(0,i.kt)("inlineCode",{parentName:"p"},"disposeBuffer")," specifies whether the buffers should be automatically cleaned up (default: true)."),(0,i.kt)("h2",{id:"usehandposes"},(0,i.kt)("inlineCode",{parentName:"h2"},"useHandPoses")),(0,i.kt)("p",null,"This hook requires a hand (",(0,i.kt)("inlineCode",{parentName:"p"},"hand")," of type ",(0,i.kt)("inlineCode",{parentName:"p"},"XRHand"),"), handedness (",(0,i.kt)("inlineCode",{parentName:"p"},"handedness")," of type ",(0,i.kt)("inlineCode",{parentName:"p"},"XRHandedness"),"), a callback function ",(0,i.kt)("inlineCode",{parentName:"p"},"onPose"),", a pose URL map (",(0,i.kt)("inlineCode",{parentName:"p"},"poseUrlMap"),"), and an optional base URL (",(0,i.kt)("inlineCode",{parentName:"p"},"baseUrl"),"). The ",(0,i.kt)("inlineCode",{parentName:"p"},"onPose")," function is called every frame with the current and previously detected poses and the offset to other poses of the current pose. It returns a function to download the current hand pose (left and right)."),(0,i.kt)("h2",{id:"useapplyspace"},(0,i.kt)("inlineCode",{parentName:"h2"},"useApplySpace")),(0,i.kt)("p",null,"This hook is used to apply the transformation of a space onto an object. It requires a reference to the object (",(0,i.kt)("inlineCode",{parentName:"p"},"ref"),"), the space (",(0,i.kt)("inlineCode",{parentName:"p"},"space"),"), and an optional callback function ",(0,i.kt)("inlineCode",{parentName:"p"},"onFrame")," that gets executed every frame with the object to retrieve its worldMatrix."),(0,i.kt)("h2",{id:"usexr"},(0,i.kt)("inlineCode",{parentName:"h2"},"useXR")),(0,i.kt)("p",null,"This hook subscribes to the current XR state. It allows to retrieve the current state via ",(0,i.kt)("inlineCode",{parentName:"p"},"useXR.getState()"),". It returns either the current XR session's state or a default state."),(0,i.kt)("h2",{id:"useenterxr"},(0,i.kt)("inlineCode",{parentName:"h2"},"useEnterXR")),(0,i.kt)("p",null,"This hook requires a mode (",(0,i.kt)("inlineCode",{parentName:"p"},"mode")," either inline, immersive-vr, or immersive-ar), and optional session initialization options ",(0,i.kt)("inlineCode",{parentName:"p"},"options"),". It returns a function to enter the described WebXR session."),(0,i.kt)("h2",{id:"usesessiongrant"},(0,i.kt)("inlineCode",{parentName:"h2"},"useSessionGrant")),(0,i.kt)("p",null,"This hook enters the described WebXR session when the user navigated to the current site while in a WebXR session. It requires optional session initialization options ",(0,i.kt)("inlineCode",{parentName:"p"},"options"),"."),(0,i.kt)("h2",{id:"uselayer"},(0,i.kt)("inlineCode",{parentName:"h2"},"useLayer")),(0,i.kt)("p",null,"This hook is used to create and manage layers. It requires a function ",(0,i.kt)("inlineCode",{parentName:"p"},"createLayer")," to create the layer via WebXR, a boolean ",(0,i.kt)("inlineCode",{parentName:"p"},"transparent")," indicating if the layer should be transparent, and an index number ",(0,i.kt)("inlineCode",{parentName:"p"},"index")," indicating the order of the layer in relation to all other layers. It returns the created layer."),(0,i.kt)("h2",{id:"uselayerupdate"},(0,i.kt)("inlineCode",{parentName:"h2"},"useLayerUpdate")),(0,i.kt)("p",null,"This hook updates the contents and transformation of a layer. It requires a reference to the object that is bound to the layer (",(0,i.kt)("inlineCode",{parentName:"p"},"ref"),"), the layer to update (",(0,i.kt)("inlineCode",{parentName:"p"},"layer"),"), an optional texture to update the layer with (",(0,i.kt)("inlineCode",{parentName:"p"},"texture"),"), a boolean indicating whether the layer is transparent (",(0,i.kt)("inlineCode",{parentName:"p"},"transparent"),"), width and height of the layer, a function to update the WebXR layer based on a scale (",(0,i.kt)("inlineCode",{parentName:"p"},"updateLayerSize"),"), and an optional function to update the layer content for dynamic content (",(0,i.kt)("inlineCode",{parentName:"p"},"updateTarget"),"). It returns either the passed texture or a texture from the render target for dynamic content."),(0,i.kt)("h2",{id:"usenativeframebufferscaling"},(0,i.kt)("inlineCode",{parentName:"h2"},"useNativeFramebufferScaling")),(0,i.kt)("p",null,"This hook provides the native frame buffer scaling. It returns a number indicating the native frame buffer scaling, or ",(0,i.kt)("inlineCode",{parentName:"p"},"undefined")," if it can't be determined. The frame buffer scaling can be provided either to the ",(0,i.kt)("inlineCode",{parentName:"p"},"XRCanvas")," or manually to the underyling ",(0,i.kt)("inlineCode",{parentName:"p"},"XR")," component to configure the frame buffer scaling of the session."),(0,i.kt)("h2",{id:"useavailableframerates"},(0,i.kt)("inlineCode",{parentName:"h2"},"useAvailableFrameRates")),(0,i.kt)("p",null,"This hook provides an array of possible frame rates. It returns a ",(0,i.kt)("inlineCode",{parentName:"p"},"Float32Array")," instance representing the available frame rates, or ",(0,i.kt)("inlineCode",{parentName:"p"},"undefined")," if they can't be determined. One frame rate from the available frame rates can be provided either to the ",(0,i.kt)("inlineCode",{parentName:"p"},"XRCanvas")," or manually to the underyling ",(0,i.kt)("inlineCode",{parentName:"p"},"XR")," component to configure the frame rate of the session."),(0,i.kt)("h2",{id:"useheighestavailableframerate"},(0,i.kt)("inlineCode",{parentName:"h2"},"useHeighestAvailableFrameRate")),(0,i.kt)("p",null,"This hook provides the highest available frame rate. It returns a number indicating the highest available frame rate, or ",(0,i.kt)("inlineCode",{parentName:"p"},"undefined")," if it can't be determined. The heighest frame rate can be provided either to the ",(0,i.kt)("inlineCode",{parentName:"p"},"XRCanvas")," or manually to the underyling ",(0,i.kt)("inlineCode",{parentName:"p"},"XR")," component to set the frame rate of the session to the heighest possible frame rate."),(0,i.kt)("h2",{id:"usexrgamepadreader"},(0,i.kt)("inlineCode",{parentName:"h2"},"useXRGamepadReader")),(0,i.kt)("p",null,"This hook provides api for reading state from gamepad bound to inputSource. It returns convenience methods for reading button state (",(0,i.kt)("inlineCode",{parentName:"p"},"readButton"),"), button value (",(0,i.kt)("inlineCode",{parentName:"p"},"readButtonValue"),") and axes values (",(0,i.kt)("inlineCode",{parentName:"p"},"readAxes"),")."),(0,i.kt)("p",null,"Available buttons and axes in Oculus 1 and 2 controllers:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"a-button")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"b-button")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"x-button")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"y-button")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"xr-standard-squeeze")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"xr-standard-thumbstick")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"xr-standard-trigger")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"thumbrest"))),(0,i.kt)("h2",{id:"usexrgamepadbutton"},(0,i.kt)("inlineCode",{parentName:"h2"},"useXRGamepadButton")),(0,i.kt)("p",null,"This hook is used to bind a press and release callbacks to a ",(0,i.kt)("inlineCode",{parentName:"p"},"inputSource.gamepad")," button state."))}h.isMDXComponent=!0}}]);